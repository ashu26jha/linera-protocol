<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Unarray"><meta name="keywords" content="rust, rustlang, rust-lang, unarray"><title>unarray - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../normalize.css"><link rel="stylesheet" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../ayu.css" disabled><link rel="stylesheet" href="../dark.css" disabled><link rel="stylesheet" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="../crates.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../unarray/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../unarray/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate unarray</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.1.4</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a class="mod" href="#">unarray</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/unarray/lib.rs.html#1-195">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="unarray"><a href="#unarray">Unarray</a></h2>
<p>Helper utilities for working with arrays of uninitialized memory.</p>
<h3 id="current-stable-rust"><a href="#current-stable-rust">Current stable Rust</a></h3>
<p>Creating arrays in Rust can be somewhat painful. Currently, your best option in the general
case is to allocate your elements in a <code>Vec</code>, then convert to an array:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">const </span>LEN: usize = <span class="number">1000</span>;
<span class="kw">let </span><span class="kw-2">mut </span>elements = Vec::with_capacity(LEN);  <span class="comment">// heap allocation here

</span><span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..LEN {
  elements.push(<span class="number">123</span>);
}

<span class="kw">let </span>result: [i32; LEN] = elements.try_into().unwrap();</code></pre></div>
<p>This needlessly allocates space on the heap, which is then immediately freed. If your type
implements <code>Copy</code>, and has a sensible default value, you can avoid this allocation by creating
an array literal (e.g. <code>[0; 1000]</code>), then iterating over each element and setting it, but this
also incurrs an unnecessary initialization cost. Why set each element to <code>0</code>, then set it
again, when you could just set it once?</p>
<h3 id="uninit_buf-and-mark_initialized"><a href="#uninit_buf-and-mark_initialized"><code>uninit_buf</code> and <code>mark_initialized</code></a></h3>
<p>The lowest-level tools provided by this library are the pair of functions: <a href="fn.uninit_buf.html" title="uninit_buf"><code>uninit_buf</code></a> and
<a href="fn.mark_initialized.html" title="mark_initialized"><code>mark_initialized</code></a>. These are ergonomic wrappers around the <a href="https://doc.rust-lang.org/1.66.1/core/mem/maybe_uninit/union.MaybeUninit.html" title="core::mem::MaybeUninit"><code>core::mem::MaybeUninit</code></a> type.
Roughly speaking, most uses of these functions will follow the following steps:</p>
<ul>
<li>Stack-allocate a region of uninitialized memory with <a href="fn.uninit_buf.html" title="uninit_buf"><code>uninit_buf</code></a></li>
<li>Initialize each element</li>
<li>Unsafely declare that all elements are initialized using <a href="fn.mark_initialized.html" title="mark_initialized"><code>mark_initialized</code></a></li>
</ul>
<p>For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>buffer = uninit_buf();  

<span class="kw">for </span>elem <span class="kw">in </span><span class="kw-2">&amp;mut </span>buffer {
  elem.write(<span class="number">123</span>);  
}

<span class="kw">let </span>result = <span class="kw">unsafe </span>{ mark_initialized(buffer) };
<span class="macro">assert_eq!</span>(result, [<span class="number">123</span>; <span class="number">1000</span>]);</code></pre></div>
<p>These functions closely map onto tools provided by <a href="https://doc.rust-lang.org/1.66.1/core/mem/maybe_uninit/union.MaybeUninit.html" title="core::mem::MaybeUninit"><code>core::mem::MaybeUninit</code></a>, so should feel
familiar. However, <a href="fn.mark_initialized.html" title="mark_initialized"><code>mark_initialized</code></a> is an unsafe function, since it’s possible to create
uninitialized values that aren’t wrapped in <code>MaybeUninit</code>. It’s up to the programmer to make
sure every element has been initialized before calling <a href="fn.mark_initialized.html" title="mark_initialized"><code>mark_initialized</code></a>, otherwise it’s UB.</p>
<p>For this, there are also fully safe APIs that cover some of the common patterns via an
extension trait on <code>[T; N]</code>:</p>
<h3 id="unarrayarrayext-extension-trait"><a href="#unarrayarrayext-extension-trait"><code>UnarrayArrayExt</code> extension trait</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// mapping an array via a `Result`
</span><span class="kw">let </span>strings = [<span class="string">&quot;123&quot;</span>, <span class="string">&quot;234&quot;</span>];
<span class="kw">let </span>numbers = strings.map_result(|s| s.parse());
<span class="macro">assert_eq!</span>(numbers, <span class="prelude-val">Ok</span>([<span class="number">123</span>, <span class="number">234</span>]));

<span class="kw">let </span>bad_strings = [<span class="string">&quot;123&quot;</span>, <span class="string">&quot;uh oh&quot;</span>];
<span class="kw">let </span>result = bad_strings.map_result(|s| s.parse::&lt;i32&gt;());
<span class="macro">assert!</span>(result.is_err());  <span class="comment">// since one of the element fails, the whole operation fails</span></code></pre></div>
<p>There is also <code>map_option</code> for functions which return an <code>Option</code></p>
<h3 id="collecting-iterators"><a href="#collecting-iterators">Collecting iterators</a></h3>
<p>Iterators generally don’t know their length at compile time. But it’s often the case that the
programmer knows the length ahead of time. In cases like this, it’s common to want to collect
these elements into an array, without heap allocation or initializing default elements.</p>
<p>Arrays don’t implement <code>FromIterator</code> for this very reason. So this library provides
<code>ArrayFromIter</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>iter = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].into_iter().map(|i| i * <span class="number">2</span>);
<span class="kw">let </span>ArrayFromIter(array) = iter.collect();  <span class="comment">// inferred to be `ArrayFromIter::&lt;i32, 3&gt;`
</span><span class="macro">assert_eq!</span>(array, <span class="prelude-val">Some</span>([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]));</code></pre></div>
<p>However, this can fail, since the iterator may not actually yield the right number of elements.
In these cases, the inner option is <code>None</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>iter = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].into_iter();
<span class="kw">match </span>iter.collect() {
  ArrayFromIter(<span class="prelude-val">Some</span>([a, b, c])) =&gt; <span class="macro">println!</span>(<span class="string">&quot;3 elements, {a}, {b}, {c}&quot;</span>),
  ArrayFromIter(<span class="prelude-val">None</span>) =&gt; <span class="macro">println!</span>(<span class="string">&quot;not 3 elements&quot;</span>),
}</code></pre></div>
<h3 id="build_array--functions"><a href="#build_array--functions"><code>build_array-*</code> functions</a></h3>
<p>Finally, it’s often the case that you want to initialize each array element based on its index.
For that, <a href="fn.build_array.html" title="build_array"><code>build_array</code></a> takes a const generic length, and a function that takes an index and
returns an element, and builds the array for you:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>unarray::<span class="kw-2">*</span>;
<span class="kw">let </span>array: [usize; <span class="number">5</span>] = build_array(|i| i * <span class="number">2</span>);
<span class="macro">assert_eq!</span>(array, [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]);</code></pre></div>
<p>There are also variants that allow fallibly constructing an array, via <a href="fn.build_array_result.html" title="build_array_result"><code>build_array_result</code></a>
or <a href="fn.build_array_option.html" title="build_array_option"><code>build_array_option</code></a>, similar to <a href="trait.UnarrayArrayExt.html#tymethod.map_result" title="UnarrayArrayExt::map_result"><code>UnarrayArrayExt::map_result</code></a> and <a href="trait.UnarrayArrayExt.html#tymethod.map_option" title="UnarrayArrayExt::map_option"><code>UnarrayArrayExt::map_option</code></a>.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ArrayFromIter.html" title="unarray::ArrayFromIter struct">ArrayFromIter</a></div><div class="item-right docblock-short">A wrapper type to collect an <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="Iterator"><code>Iterator</code></a> into an array</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.UnarrayArrayExt.html" title="unarray::UnarrayArrayExt trait">UnarrayArrayExt</a></div><div class="item-right docblock-short">An extension trait that adds methods to <code>[T; N]</code></div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.build_array.html" title="unarray::build_array fn">build_array</a></div><div class="item-right docblock-short">Build an array with a function that creates elements based on their index</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.build_array_option.html" title="unarray::build_array_option fn">build_array_option</a></div><div class="item-right docblock-short">Build an array with a function that creates elements based on their value, short-circuiting if
any index returns a <code>None</code></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.build_array_result.html" title="unarray::build_array_result fn">build_array_result</a></div><div class="item-right docblock-short">Build an array with a function that creates elements based on their value, short-circuiting if
any index returns an <code>Err</code></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.mark_initialized.html" title="unarray::mark_initialized fn">mark_initialized</a><sup title="unsafe function">⚠</sup></div><div class="item-right docblock-short">Convert a <code>[MaybeUninit&lt;T&gt;; N]</code> to a <code>[T; N]</code></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.uninit_buf.html" title="unarray::uninit_buf fn">uninit_buf</a></div><div class="item-right docblock-short">Create an array of unintialized memory</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="unarray" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.1 (90743e729 2023-01-10)" ></div></body></html>